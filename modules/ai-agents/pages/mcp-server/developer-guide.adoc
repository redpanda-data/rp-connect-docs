=  Build an MCP Server in Redpanda Connect
:description: Learn how to build and deploy MCP servers with self-managed Redpanda Connect. This guide covers concepts, patterns, and best practices.

This guide teaches you how to build xref:ai-agents:mcp-server/overview.adoc[MCP servers with self-managed Redpanda Connect]. MCP servers run as part of your Redpanda Connect deployment and expose tools that AI clients can call using the Model Context Protocol.

:tip-caption: New to MCP?

TIP:  Start with the xref:ai-agents:mcp-server/quickstart.adoc[quickstart guide] for a 5-minute introduction.

:tip-caption: Tip

[[quick-start]]
== Quick reference

Run the following commands to create and start a basic MCP server with Redpanda Connect:

[source,bash]
----
# 1. Create a new MCP server project
rpk connect mcp-server init

# 2. Remove example files
rm resources/**/example-*.yaml

# 3. Create your first tool (see examples on this page)
# Edit resources/processors/my-tool.yaml

# 4. Lint your configuration
rpk connect mcp-server lint

# 5. Start the server
rpk connect mcp-server --address localhost:4195

# 6. Connect Claude Code (in another terminal)
claude mcp add local -- npx mcp-remote http://localhost:4195/sse
----

[[examples]]
=== Common tool examples

==== External API call

Create `resources/processors/weather-api.yaml`:

[source,yaml]
----
include::ai-agents:example$resources/processors/weather-api.yaml[]
----

==== Database query

Create `resources/processors/database-query.yaml`:

[source,yaml]
----
include::ai-agents:example$resources/processors/database-query.yaml[]
----

==== Redpanda consumer

Create `resources/inputs/redpanda-consume.yaml`:

[source,yaml]
----
include::ai-agents:example$resources/inputs/redpanda-consume.yaml[]
----

TIP: For more patterns including workflows, error handling, and observability, see xref:ai-agents:mcp-server/pipeline-patterns.adoc[].

== Prerequisites

* The xref:get-started:quickstarts/rpk.adoc[Redpanda CLI (`rpk`)]
* At least version 4.56.0 of Redpanda Connect
+
If you need to upgrade, see xref:get-started:upgrade/rpk-upgrade.adoc[].
* Basic understanding of YAML, HTTP APIs, and event-stream processing concepts
* (Optional) Claude Desktop or other MCP-compatible AI client for testing

TIP: For a quickstart, see xref:ai-agents:mcp-server/quickstart.adoc[].

== Concepts and architecture

[cols="1,3"]
|===
| Concept | Description

| MCP Server
| A service that exposes tools through the Model Context Protocol. Start a server with `rpk connect mcp-server`.

| Tool
| A single request/response operation. Implemented as a YAML configuration with `meta.mcp` metadata.

| Contract
| The formal interface (description, parameters, types) declared in `meta.mcp`. AI clients use this to understand how to call your tool.

| Configuration
| A YAML file defining data flow through inputs, processors, and outputs. Receives JSON input, returns structured results.

| Secrets
| Store as environment variables (`${ENV_VAR}`). Never hardcode credentials in YAML.
|===

== Development workflow

[.text-center]
****
*Initialize* → *Design Contract* → *Implement* → *Test* → *Connect Client* → *Publish (Optional)*
****

[cols="1,3,2"]
|===
| Step | What to do | Section

| 1
| Initialize project with `rpk connect mcp-server init`
| <<initialize>>

| 2
| Design tool contract with `meta.mcp` metadata
| <<contract>>

| 3
| Implement logic using Redpanda Connect components
| <<create-tool>>

| 4
| Lint and start server
| <<start-server>>

| 5
| Connect AI client (Claude Code, etc.)
| <<connect>>

| 6
| Publish to MCP registry (optional)
| <<publish>>
|===

[[initialize]]
== Initialize project

Initialize a new MCP server project:

[source,bash]
----
rpk connect mcp-server init
----

This creates the following structure:

[.no-copy]
----
├── o11y/                    # Observability configs
│   ├── metrics.yaml
│   └── tracer.yaml
└── resources/               # Tool definitions
    ├── caches/
    ├── inputs/
    ├── outputs/
    └── processors/
----

Each YAML file contains one tool. File location determines component type: `resources/inputs/` for input tools, `resources/outputs/` for output tools, `resources/processors/` for processor tools, and `resources/caches/` for cache tools.

Remove example files before creating your own:

[source,bash]
----
rm resources/**/example-*.yaml
----

[[contract]]
== Design tool contract

<<<<<<< Updated upstream
// Tool contract guidance - single-sourced from partial
include::ai-agents:partial$mcp/tool-contract-guidance.adoc[]
=======
Every MCP tool needs a contract that AI clients use to understand how to call it.

[source,yaml]
----
meta:
  mcp:
    enabled: true # <1>
    description: "Fetch user profile data by ID" # <2>
    properties: # <3>
      - name: user_id
        type: string
        description: "The unique user identifier"
        required: true
      - name: include_orders
        type: boolean
        description: "Include order history (default: false)"
        required: false
----
<1> Enable MCP exposure for this tool.
<2> Clear, action-oriented description for AI clients.
<3> Define input parameters with types and descriptions.

Contract design guidelines:

* Keep descriptions task-oriented and concise
* Use only `string`, `number`, or `boolean` types
* Mark only mandatory fields as `required: true`
* Document default values in descriptions
* Don't expose implementation details
* Don't use complex nested types
>>>>>>> Stashed changes

[[create-tool]]
== Create your tool

=== Best practices

[cols="1,3"]
|===
| Principle | Description

| Single responsibility
| Each tool does one thing well.

| Descriptive naming
| Use `fetch-user-profile`, not `get-data`. The label becomes the tool name.

| Input validation
| Always validate user inputs using xref:guides:bloblang/about.adoc[Bloblang].

| Error handling
| Use `try`/`catch` blocks with meaningful error messages.

| Environment secrets
| Reference credentials as `${ENV_VAR}`, never hardcode.
|===

=== Complete example

Here's a production-ready tool showing all best practices:

[source,yaml]
----
include::ai-agents:example$resources/processors/weather-service.yaml[]
----

<<<<<<< Updated upstream
// YAML configuration rules - single-sourced from partial
include::ai-agents:partial$mcp/yaml-config-rules-connect.adoc[]
=======
For more patterns, see xref:ai-agents:mcp-server/pipeline-patterns.adoc[].

=== YAML configuration rules
>>>>>>> Stashed changes

// Property restrictions table - single-sourced from partial
include::ai-agents:partial$mcp/property-restrictions-table.adoc[]

<<<<<<< Updated upstream
// Configuration examples - single-sourced from partial
include::ai-agents:partial$mcp/config-examples.adoc[]
=======
[cols="1,1", options="header"]
|===
| Directory | Component type

| `resources/inputs/`
| Input component

| `resources/outputs/`
| Output component

| `resources/processors/`
| Processor component

| `resources/caches/`
| Cache component
|===

Common mistakes to avoid:

- Wrapping components in `input:` or `output:` blocks
- Multiple top-level component types in one file (like having separate `input:`, `processors:`, and `output:` sections)
- Using `try`/`catch` as a single processor (must be separate)
- Hardcoding secrets instead of using `${ENV_VAR}`
- Generic tool names like `get-data` or `processor1`.

NOTE: Outputs and inputs can include processors as part of their configuration. For example, an output can have a `processors:` section to transform data before publishing. See xref:ai-agents:mcp-server/pipeline-patterns.adoc#outputs-with-processors[outputs with processors] for examples.

=== Property restrictions by component type

Different component types have different property capabilities when exposed as MCP tools:

[cols="1,2,2"]
|===
| Component type | Property support | Details

| `input`
| Only supports `count` property
| AI clients can specify how many messages to read, but you cannot define custom properties.

| `cache`
| No custom properties
| Properties are hardcoded to `key` and `value` for cache operations.

| `output`
| Custom properties supported
| AI sees properties as an array for batch operations: `[{prop1, prop2}, {prop1, prop2}]`.

| `processor`
| Custom properties supported
| You can define any properties needed for data processing operations.
|===

.Correct example when inside resources/inputs/
[source,yaml]
----
label: event-reader
redpanda:
  seed_brokers: [ "${REDPANDA_BROKERS}" ]
  topics: [ "events" ]
  consumer_group: "mcp-reader"

meta:
  mcp:
    enabled: true
    description: "Consume events from Redpanda"
----

.Correct example when inside resources/processors/
[source,yaml]
----
label: fetch-example-data
processors:
  - label: safe_operation
    try:
      - http:
          url: "https://api.example.com/data"
          timeout: "10s"
      - mutation: |
          root = this.merge({"processed": true})

  - label: handle_errors
    catch:
      - mutation: |
          root = {
            "error": "Operation failed",
            "details": error()
          }
----

.Correct example of output with processors when inside resources/outputs/
[source,yaml]
----
label: publish-with-transform
processors:  # <1>
  - mutation: |
      root = this
      root.published_at = now()
redpanda:
  seed_brokers: [ "${REDPANDA_BROKERS}" ]
  topic: "processed-events"
meta:
  mcp:
    enabled: true
    description: "Publish data to Redpanda with timestamp"
----
<1> Processors within an output are allowed and transform data before publishing.

.Incorrect (do not include the input wrapper)
[source,yaml]
----
label: incorrect-example
input:
  redpanda:
    seed_brokers: [ "${REDPANDA_BROKERS}" ]
    topics: [ "events" ]
----

.Incorrect (multiple top-level component types in one file)
[source,yaml]
----
label: incorrect-example
input:  # <1>
  redpanda: { ... }
processors:  # <1>
  - mutation: { ... }
output:  # <1>
  redpanda: { ... }
----
<1> This file has three top-level component types. Each must be in its own file.
>>>>>>> Stashed changes

.Incorrect (try/catch as single processor)
[source,yaml]
----
label: incorrect-example
processors:
  - label: operation
    try:
      - http: { ... }
    catch:
      - mutation: { ... }
----

[[troubleshooting]]
== Troubleshoot

This section covers common issues and debugging techniques when developing MCP tools with Redpanda Connect.

=== Tool not appearing in MCP client

Check that `meta.mcp.enabled: true` is set. Verify the MCP server is running on the expected port. Ensure the tool has the correct tag specified in the server startup command.

=== Unable to infer component type

If you see errors like:

[source]
----
resources/inputs/redpanda-consume.yaml(1,1) unable to infer component type: [input processors cache_resources meta]
resources/outputs/redpanda-publish.yaml(1,1) unable to infer component type: [processors output meta]
----

This means your YAML file contains more than one top-level component type, or uses a wrapper (such as `input:` or `output:`) that is not allowed. Each YAML file must contain only a single top-level component type, and should not be wrapped in an `input:` or `output:` block.

Note that outputs and inputs can include `processors:` sections as part of their configuration. The error occurs when you have multiple top-level types like having both `input:` and `output:` in the same file.

To fix this, split out each top-level component type into its own file (for example, one file for the input, one for standalone processors, one for the output). See <<yaml-configuration-rules, YAML configuration rules>> for correct examples.

.Example of incorrect YAML
[source,yaml]
----
input:
  redpanda: { ... }
processors:
  - mutation: { ... }
output:
  redpanda: { ... }
----

.Example of correct YAML (for an input)
[source,yaml]
----
label: my_input
redpanda:
  seed_brokers: [ "${REDPANDA_BROKERS}" ]
  topics: [ "events" ]
  consumer_group: "mcp-reader"
meta:
  mcp:
    enabled: true
    description: "Consume events from Redpanda"
----

[[start-server]]
== Start the MCP server

. Navigate to the directory where you <<initialize, initialized the MCP server project>>.

. Lint your configuration files before starting the server:
+
[source,bash]
----
rpk connect mcp-server lint
----
+
This command checks all YAML files in your `resources` directory for errors or misconfigurations. Fix any issues reported before proceeding.

. Start the MCP server to expose all your tools over HTTP:
+
[source,bash]
----
rpk connect mcp-server --address localhost:4195
----
+
This command creates an MCP server listening on `localhost:4195`.
+
You should see output like this:
+
[.no-copy]
----
time=2025-06-27T15:20:27.976+01:00 level=INFO msg="Registering processor tool" label=...
time=2025-06-27T15:20:27.978+01:00 level=INFO msg="Successfully loaded Redpanda license" expires_at=2035-06-25T15:20:27+01:00 license_org="" license_type="open source"
----

=== Expose a subset of tools

To expose only a subset of tools, use the `--tag` flag. This helps you keep experiments isolated, avoid exposing sensitive functionality accidentally, and create sets of tools that are relevant to specific agents or workflows.

For example, to expose only tools tagged with `example`, start the server with:

[,bash]
----
rpk connect mcp-server --address localhost:4195 --tag example
----

[[connect]]
== Connect an MCP client

You can connect any MCP-compatible client to your MCP server using the server's HTTP endpoint. Most clients require the server address and may support authentication or custom headers.

To connect a generic MCP client:

. Ensure your MCP server is running and accessible at the desired address (for example, `http://localhost:4195`).

. Configure your client with the MCP server's endpoint. For example: `http://localhost:4195/sse`.

Refer to your client's documentation for details on supported options and advanced configuration. For a list of example clients, see the link:https://modelcontextprotocol.io/clients[MCP documentation^].

[[connect-claude]]
=== Connect Claude Code to your MCP server

To connect Claude Code to your MCP server, you need to expose a live event stream that Claude can consume. This is done using the link:https://www.npmjs.com/package/mcp-remote[mcp-remote utility^], which bridges your local service to Claude's MCP interface.

[source,bash]
----
claude mcp add local -- npx mcp-remote http://localhost:4195/sse
----

You should see output like this:

[.no-copy]
----
Added stdio MCP server local with command: npx mcp-remote http://localhost:4195/sse to local config
----

Verify the connection:

[source,bash]
----
claude /mcp
----

Press *Enter* until you see your tools listed.

NOTE: How it works: `mcp-remote` connects to the SSE endpoint at `http://localhost:4195/sse`, converts events into MCP message format, and pipes them to Claude Code via stdout. Claude reads these messages from the subprocess, treating them as if they were emitted by a native MCP agent.

[[publish]]
== Publish your MCP server (optional)

To make your MCP server discoverable by AI clients and agents, you can publish it to an MCP registry. This also enables you to provide authentication and access control for your tools.

See the official guide for publishing and securing your server: link:https://github.com/modelcontextprotocol/registry/blob/main/docs/guides/publishing/publish-server.md[MCP Registry Publishing Guide^].

== Suggested reading

* xref:components:about.adoc[Redpanda Connect components reference]
* xref:ai-agents:mcp-server/pipeline-patterns.adoc[]
* xref:guides:bloblang/about.adoc[Bloblang language guide]
* link:https://docs.anthropic.com/en/docs/mcp[Model Context Protocol documentation^]
* xref:ai-agents:mcp-server/quickstart.adoc[MCP Server quickstart]
