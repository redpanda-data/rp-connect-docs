// =============================================================================
// PARTIAL: production-workflows.adoc
// =============================================================================
//
// INCLUDED BY:
//   - rp-connect-docs: modules/ai-agents/pages/mcp-server/tool-patterns.adoc
//   - cloud-docs: modules/ai-agents/pages/mcp/remote/tool-patterns.adoc
//
// INCLUDE SYNTAX:
//   Connect: include::ai-agents:partial$mcp/tool-patterns/production-workflows.adoc[]
//   Cloud:   include::redpanda-connect:ai-agents:partial$mcp/tool-patterns/production-workflows.adoc[]
//
// ATTRIBUTES USED:
//   - env-cloud: Switches secrets partial and xref targets for Cloud context
//
// DEPENDENCIES:
//   - partials/mcp/tool-patterns/secrets-cloud.adoc (included via ifdef)
//   - partials/mcp/tool-patterns/secrets-connect.adoc (included via ifndef)
//   - example$best-practices/production-workflows/*.yaml
//   - example$resources/processors/*.yaml
// =============================================================================

== Production workflows and observability

Build enterprise-grade tools with error handling, validation, multi-step workflows, and monitoring.

=== Parameter validation and type coercion

Always validate and coerce input parameters to ensure your tools are robust:

[source,yaml]
----
include::example$best-practices/production-workflows/param-validation.yaml[tags=param-validation]
----

=== Dynamic configuration

Build tools that adapt their behavior based on input parameters:

[source,yaml]
----
include::example$best-practices/production-workflows/dynamic-config.yaml[tags=dynamic-config]
----

=== Error handling and fallbacks

Implement error handling to make your tools reliable:

[source,yaml]
----
include::example$best-practices/production-workflows/error-fallbacks.yaml[tags=error-fallbacks]
----

=== Conditional processing

Build tools that branch based on input or data characteristics:

[source,yaml]
----
include::example$best-practices/production-workflows/conditional-processing.yaml[tags=conditional-processing]
----

// Secrets section - deployment-specific
ifdef::env-cloud[]
include::ai-agents:partial$mcp/tool-patterns/secrets-cloud.adoc[]
endif::[]
ifndef::env-cloud[]
include::ai-agents:partial$mcp/tool-patterns/secrets-connect.adoc[]
endif::[]

=== Monitoring, debugging, and observability

Use structured logging, request tracing, and performance metrics to gain insights into tool execution.

[source,yaml]
----
include::ai-agents:example$resources/processors/observable-tool.yaml[]
----

Observability features:

* *Correlation IDs*: Use `uuid_v7()` to generate unique request identifiers for tracing
* *Execution timing*: Track how long your tools take to execute using nanosecond precision
* *Structured logging*: Include consistent fields like `request_id`, `duration_ms`, `tool_name`
* *Request/response metadata*: Log input parameters and response characteristics
* *Success tracking*: Monitor whether operations complete successfully

You can test this pattern by invoking the tool with valid and invalid parameters, and observe the structured logs for tracing execution flow. For example, with a user ID of 1, you might see logs like:

[source,json]
----
{
  "metadata": {
    "execution_time_ms": 0.158977,
    "request_id": "019951ab-d07d-703f-aaae-7e1c9a5afa95",
    "success": true,
    "timestamp": "2025-09-16T08:37:18.589Z",
    "tool": "observable_tool"
  },
  "trace": {
    "request_id": "019951ab-d07d-703f-aaae-7e1c9a5afa95",
    "timestamp": "2025-09-16T08:37:18.589Z",
    "tool": "observable_tool",
    "version": "1.0.0"
  },
  "user_id": "1"
}
----

See also: xref:components:processors/log.adoc[`log` processor], xref:components:processors/try.adoc[`try` processor], xref:guides:bloblang/functions.adoc[Bloblang functions] (for timing and ID generation)

=== Multi-step data enrichment

Build tools that combine data from multiple sources.

This workflow fetches customer data from a SQL database, enriches it with recent order history, and computes summary metrics.

[source,yaml]
----
include::ai-agents:example$resources/processors/customer-enrichment.yaml[]
----

See also: xref:components:processors/sql_select.adoc[`sql_select` processor], xref:guides:bloblang/about.adoc[Bloblang functions] (for data manipulation and aggregations)

=== Workflow orchestration

Coordinate complex workflows with multiple steps and conditional logic.

This workflow simulates a complete order processing pipeline with mock data for inventory and processing tiers. This allows you to test the full logic without needing real external systems.

[source,yaml]
----
include::ai-agents:example$resources/processors/order-workflow.yaml[]
----

For the input `{"order_id": "ORD001", "product_id": "widget-001", "quantity": 5, "total": 250, "customer_tier": "vip"}`, the workflow produces:

[source,json]
----
{
  "assigned_rep": "vip-team@company.com",
  "available_quantity": 100,
  "customer_tier": "vip",
  "estimated_fulfillment": "TBD - calculated based on processing tier",
  "inventory_check": "passed",
  "order_id": "ORD001",
  "order_status": "processed",
  "perks": [
    "expedited_shipping",
    "white_glove_service"
  ],
  "priority_score": 90,
  "processed_at": "2025-09-16T09:05:29.138Z",
  "processing_tier": "vip",
  "processing_time_estimate": "1-2 hours",
  "processing_time_hours": 2,
  "product_id": "widget-001",
  "product_name": "Standard Widget",
  "quantity": 5,
  "total": 250
}
----

Notice how the workflow:

. Preserves original input: `order_id`, `product_id`, `quantity`, `total`, and `customer_tier` pass through unchanged.
. Adds inventory data: `available_quantity`, `product_name`, and `inventory_check` status from the mock lookup.
. Routes by customer tier: Since `customer_tier` is `vip`, it gets VIP processing with special `perks` and priority.
. Enriches with processing metadata: `assigned_rep`, `priority_score`, `processing_tier`, and time estimates.
. Finalizes with timestamps: `order_status`, `processed_at`, and calculated `processing_time_hours`.

